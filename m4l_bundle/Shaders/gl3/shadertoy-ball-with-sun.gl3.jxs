<jittershader name="stripes">
    <param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
    <param name="textureMatrix0" type="mat4" state="TEXTURE0_MATRIX" />
    <param name="position" type="vec3" state="POSITION" />
    <param name="texcoord" type="vec2" state="TEXCOORD" />
    <param name="iResolution" type="vec2" state="TEXDIM0" />
    <param name="iMouse" type="vec4" default="0 0 0 0" />
    <param name="iTime" type="float" default="0" />
	<param name="dummytex" type="int" default="0" />
	<param name="iChannel0" type="int" default="1" />
	<param name="iChannel1" type="int" default="2" />
	<param name="iChannel2" type="int" default="3" />
    <param name="iChannel3" type="int" default="4" />
	<param name="fog_dyn" type="float" default="0.11" />
	<param name="DETAIL" type="int" default="1" />
	<param name="TEXTURE" type="float" default="2.0" />
	<param name="ROTATE" type="float" default="1.5" />
	<param name="ROTATE_SIN" type="float" default="0.5" />
	<param name="CUTS" type="float" default="3.14" />
	<param name="ZOOM" type="float" default="2.5" />
	<param name="FRAGMENTS" type="float" default="0.1" />
	<param name="red" type="float" default="1." />
	<param name="green" type="flaot" default="1." />
	<param name="blue" type="float" default="1." />
	<param name="red_neurons" type="float" default="1." />
	<param name="green_neurons" type="flaot" default="1." />
	<param name="blue_neurons" type="float" default="1." />
	<param name="brightness_neurons" type="float" default="3." />
	<param name="sharpness_neurons" type="float" default="30" />
	<param name="spreading_neurons" type="float" default="1.2" />
	<param name="zoom_neurons" type="float" default="15." />
	<param name="red_neurons2" type="float" default="1." />
	<param name="green_neurons2" type="flaot" default="0." />
	<param name="blue_neurons2" type="float" default="1." />
	<param name="brightness_neurons2" type="float" default="1." />
	<param name="sharpness_neurons2" type="float" default="4" />
	<param name="spreading_neurons2" type="float" default="1.2" />
	<param name="background_blending" type="float" default="0.0" />
	<param name="fog_strength" type="float" default="0.5" />
	<param name="neuron_blending" type="float" default="0.5" />
    <language name="glsl" version="1.5">
        <bind param="modelViewProjectionMatrix" program="vp" />
        <bind param="textureMatrix0" program="vp" />
        <bind param="position" program="vp" />
        <bind param="texcoord" program="vp" />
        <bind param="iTime" program="fp" />
        <bind param="iMouse" program="fp" />
        <bind param="iResolution" program="fp" />
		<bind param="dummytex" program="fp" />
		<bind param="iChannel0" program="fp" />
		<bind param="iChannel1" program="fp" />
		<bind param="iChannel2" program="fp" />
        <bind param="iChannel3" program="fp" />
		<bind param="fog_dyn" program="fp" />
		<bind param="DETAIL" program="fp" />
		<bind param="TEXTURE" program="fp" />
		<bind param="ROTATE" program="fp" />
		<bind param="ROTATE_SIN" program="fp" />
		<bind param="CUTS" program="fp" />
		<bind param="ZOOM" program="fp" />
		<bind param="FRAGMENTS" program="fp" />
		<bind param="red" program="fp" />
		<bind param="green" program="fp" />
		<bind param="blue" program="fp" />
		<bind param="red_neurons" program="fp" />
		<bind param="green_neurons" program="fp" />
		<bind param="blue_neurons" program="fp" />
		<bind param="brightness_neurons" program="fp" />
		<bind param="sharpness_neurons" program="fp" />
		<bind param="spreading_neurons" program="fp" />
		<bind param="zoom_neurons" program="fp" />
		<bind param="red_neurons2" program="fp" />
		<bind param="green_neurons2" program="fp" />
		<bind param="blue_neurons2" program="fp" />
		<bind param="brightness_neurons2" program="fp" />
		<bind param="sharpness_neurons2" program="fp" />
		<bind param="spreading_neurons2" program="fp" />
		<bind param="background_blending" program="fp" />
		<bind param="fog_strength" program="fp" />
		<bind param="neuron_blending" program="fp" />
		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 position;
			in vec2 texcoord;
			out jit_PerVertex {
				vec2 texcoord;
			} jit_out;
			uniform mat4 modelViewProjectionMatrix;
			uniform mat4 textureMatrix0;
			
			
			void main(void) {
				gl_Position = modelViewProjectionMatrix*vec4(position, 1.);
				jit_out.texcoord = vec2(textureMatrix0*vec4(texcoord, 0., 1.));
			}
		]]>
		</program>      
        <program name="fp" type="fragment"  >
        <![CDATA[
            #version 330 core
            
            in jit_PerVertex {
                vec2 texcoord;
            } jit_in;
            out vec4 outColor;

            uniform vec2 texcoord;
            uniform float iTime;
            uniform vec2 iResolution;
            uniform vec4 iMouse;
			uniform sampler2DRect dummytex;
			uniform sampler2D iChannel0;
			uniform sampler2D iChannel1;
			uniform sampler2D iChannel2;
            uniform sampler2D iChannel3;
			uniform float fog_dyn;
			uniform int DETAIL;
			uniform float TEXTURE;
			uniform float ROTATE;
			uniform float ROTATE_SIN;
			uniform float CUTS;
			uniform float ZOOM;
			uniform float FRAGMENTS;
			uniform float red_neurons;
			uniform float green_neurons;
			uniform float blue_neurons;
			uniform float brightness_neurons;
			uniform float sharpness_neurons;
			uniform float spreading_neurons;
			uniform float zoom_neurons;
			uniform float red;
			uniform float green;
			uniform float blue;
			uniform float red_neurons2;
			uniform float green_neurons2;
			uniform float blue_neurons2;
			uniform float brightness_neurons2;
			uniform float sharpness_neurons2;
			uniform float spreading_neurons2;
			uniform float background_blending;
			uniform float fog_strength;
			uniform float neuron_blending;

// <<<<<<<<< START SHADERTOY PASTE

			// Protean clouds by nimitz (twitter: @stormoid)
// https://www.shadertoy.com/view/3l23Rh
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Contact the author for other licensing options

/*
	Technical details:

	The main volume noise is generated from a deformed periodic grid, which can produce
	a large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple
	fetches of volume gradient computation for improved lighting.

	To further accelerate marching, since the volume is smooth, more than half the the density
	information isn't used to rendering or shading but only as an underlying volume	distance to 
	determine dynamic step size, by carefully selecting an equation	(polynomial for speed) to 
	step as a function of overall density (not necessarialy rendered) the visual results can be 
	the	same as a naive implementation with ~40% increase in rendering performance.

	Since the dynamic marching step size is even less uniform due to steps not being rendered at all
	the fog is evaluated as the difference of the fog integral at each rendered step.

*/

// Remnant X
// by David Hoskins.
// Thanks to boxplorer and the folks at 'Fractalforums.com'
// HD Video:- https://www.youtube.com/watch?v=BjkK9fLXXo0

// #define STEREO
/*--------------------------------------------------------------------------------------
License CC0 - http://creativecommons.org/publicdomain/zero/1.0/
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.
----------------------------------------------------------------------------------------
^This means do anything you want with this code. Because we are programmers, not lawyers.
-Otavio Good
*/

// Set this to change detail level. [1 - 10] is a good range.
//NUM_SIN_REPS = DETAIL;
const int MAX_MARCH_REPS = 100;
const float MARCH_DISTANCE_MULTIPLIER = 0.1;

float localTime = 0.0;
	
// Set this to change detail level. [1 - 10] is a good range.
//NUM_SIN_REPS = DETAIL;
mat2 rotate2D(float r) {
    return mat2(cos(r), sin(r), -sin(r), cos(r));
}


vec3 wet_neurons(vec4 fragColor, vec2 fragCoord) {
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;
    vec3 col = vec3(0);
    float t = iTime;
    
    vec2 n = vec2(0),q;
    vec2 N = vec2(0);
    vec2 p = uv + t/10.;
    float S = zoom_neurons;
    mat2 m = rotate2D(1.);

    for(float j=0.;j++<sharpness_neurons;){
      p*=m;
      n*=m;
      q=p*S+j+n+t;
      n+=sin(q);
      N+=cos(q)/S;
      S*=spreading_neurons;
    }
    col = vec3(red_neurons, green_neurons, blue_neurons) * brightness_neurons * ((N.x + N.y + 0.005)+.005/length(N));
    return col;
}

vec3 wet_neurons2(vec4 fragColor, vec2 fragCoord) {
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;
    vec3 col = vec3(0);
    float t = iTime;
    
    vec2 n = vec2(0),q;
    vec2 N = vec2(0);
    vec2 p = uv + t/10.;
    float S = zoom_neurons;
    mat2 m = rotate2D(1.);

    for(float j=0.;j++<sharpness_neurons2;){
      p*=m;
      n*=m;
      q=p*S+j+n+t;
      n+=sin(q);
      N+=cos(q)/S;
      S*=spreading_neurons2;
    }
    col = vec3(red_neurons2, green_neurons2, blue_neurons2) * brightness_neurons2 * ((N.x + N.y + 0.005)+.005/length(N));
    return col;
}


// some noise functions
float Hash(float f)
{
    return fract(cos(f)*7561.0);
}
float Hash2d(vec2 uv)
{
    float f = uv.x + uv.y * 521.0;	// repeats after this value
    float rand = fract(cos(f)*104729.0);
    return rand;
}
vec2 Hash2(vec2 v)
{
    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));
}
float Hash3d(vec3 uv)
{
    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;
    return fract(sin(f)*110003.9);
}

float mixS(float f0, float f1, float a)
{
    if (a < 0.5) return f0;
    return f1;
}

float mixC(float f0, float f1, float a)
{
    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);
}

float mixP(float f0, float f1, float a)
{
    return mix(f0, f1, a*a*(2.0-TEXTURE*a));
}
vec2 mixP2(vec2 v0, vec2 v1, float a)
{
    return mix(v0, v1, a*a*(3.0-2.0*a));
}

float mixSS(float f0, float f1, float a)
{
    return mix(f0, f1, smoothstep(0.0, 1.0, a));
}

const vec2 zeroOne = vec2(0.0, 1.0);
float noise2dVec(vec2 uv)
{
    vec2 fr = fract(uv);
    vec2 fl = floor(uv);
    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));
    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));
    vec2 xMix = mixP2(h0, h1, fr.x);
    return mixC(xMix.x, xMix.y, fr.y);
}
float noise2d(vec2 uv)
{
    vec2 fr = fract(uv);
    vec2 fl = floor(uv);
    float h00 = Hash2d(fl);
    float h10 = Hash2d(fl + zeroOne.yx);
    float h01 = Hash2d(fl + zeroOne);
    float h11 = Hash2d(fl + zeroOne.yy);
    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);
}
float noise(vec3 uv)
{
    vec3 fr = fract(uv.xyz);
    vec3 fl = floor(uv.xyz);
    float h000 = Hash3d(fl);
    float h100 = Hash3d(fl + zeroOne.yxx);
    float h010 = Hash3d(fl + zeroOne.xyx);
    float h110 = Hash3d(fl + zeroOne.yyx);
    float h001 = Hash3d(fl + zeroOne.xxy);
    float h101 = Hash3d(fl + zeroOne.yxy);
    float h011 = Hash3d(fl + zeroOne.xyy);
    float h111 = Hash3d(fl + zeroOne.yyy);
    return mixP(
        mixP(mixP(h000, h100, fr.x),
             mixP(h010, h110, fr.x), fr.y),
        mixP(mixP(h001, h101, fr.x),
             mixP(h011, h111, fr.x), fr.y)
        , fr.z);
}

float PI=3.14159265;

vec3 saturate(vec3 a) { return clamp(a, 0.0, 0.0); }
vec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }
float saturate(float a) { return clamp(a, 0.0, 1.0); }

vec3 RotateX(vec3 v, float rad)
{
  float cos = cos(rad);
  float sin = sin(rad);
  //if (RIGHT_HANDED_COORD)
  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);
  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);
}
vec3 RotateY(vec3 v, float rad)
{
  float cos = cos(rad);
  float sin = sin(rad);
  //if (RIGHT_HANDED_COORD)
  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);
  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);
}
vec3 RotateZ(vec3 v, float rad)
{
  float cos = cos(rad);
  float sin = sin(rad);
  //if (RIGHT_HANDED_COORD)
  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);
}


// This function basically is a procedural environment map that makes the sun
vec3 sunCol = vec3(258.0, 228.0, 170.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(
vec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)
{
	vec3 localRay = normalize(rayDir);
	float dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);
	float sunIntensity = 0.015 / dist;
	sunIntensity = pow(sunIntensity, 0.3)*100.0;

    sunIntensity += exp(-dist*12.0)*300.0;
	sunIntensity = min(sunIntensity, 40000.0);
    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;
	return sunCol * sunIntensity*0.0425;
}
vec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)
{
	vec3 localRay = normalize(rayDir);
	float dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);
	float sunIntensity = 0.05 / dist;
    sunIntensity += exp(-dist*12.0)*300.0;
	sunIntensity = min(sunIntensity, 40000.0);
	return sunCol * sunIntensity*0.025;
}

vec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);

vec3 camPos = vec3(0.0), camFacing;
vec3 camLookat=vec3(0,0.0,0);

float SinRep(float a)
{
    float h = 0.0;
    float mult = 1.0;
    for (int i = 0; i < DETAIL; i++)
    {
        h += (cos(a*mult)/(mult));
        mult *= 2.0;
    }
    return h;
}

vec2 DistanceToObject(vec3 p)
{
    float material = 0.0;
    float h = 0.0;
    p = RotateY(p, p.y*ROTATE_SIN - cos(localTime)*ROTATE);
    h += SinRep(RotateY(p, p.z*3.14*0.15).x);
    h += SinRep(RotateZ(p, p.x*3.14*0.15).y);
    h += SinRep(RotateX(p, p.y*CUTS*0.15).z);
    material = h;
    //h += SinRep(RotateX(p, p.y).z);
    //h += SinRep(RotateZ(p, sin(h)).y);
    //h += SinRep(RotateY(p, h*1.0).x);
    //h += SinRep(p.x+h)*0.5;
    //h += SinRep(p.y+h)*0.5;
    float final = (length(p)-1*(ZOOM) - h*(FRAGMENTS + sin(localTime)*0.35));
    return vec2(final, material);
}

float distFromSphere;
float IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)
{
	// Use dot product along line to find closest point on line
	vec3 eyeVec2 = normalize(posB-posA);
	float dp = dot(eyeVec2, pos - posA);
	vec3 pointOnLine = eyeVec2 * dp + posA;
	// Clamp that point to line end points if outside
	//if ((dp - radius) < 0) pointOnLine = posA;
	//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;
	// Distance formula from that point to sphere center, compare with radius.
	float distance = length(pointOnLine - pos);
	float ac = radius*radius - distance*distance;
	float rightLen = 0.0;
	if (ac >= 0.0) rightLen = sqrt(ac);
	intersectA2 = pointOnLine - eyeVec2 * rightLen;
	intersectB2 = pointOnLine + eyeVec2 * rightLen;
	distFromSphere = distance - radius;
	if (distance <= radius) return 1.0;
	return 0.0;
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	vec3 wet_neurons_smooth = wet_neurons2(fragColor, fragCoord);
	vec3 wet_neurons_col = mix(wet_neurons(fragColor, fragCoord), wet_neurons_smooth, neuron_blending);

	
    localTime = iTime - 1.6;
	// ---------------- First, set up the camera rays for ray marching ----------------
	vec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;
	uv += wet_neurons_smooth.xy*(1-background_blending);

	// Camera up vector.
	vec3 camUp=vec3(0,1,0); // vuv

	// Camera lookat.
	camLookat=vec3(0,0.0,0);	// vrp

    // debugging camera
    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime * 0.123;
	float my=-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;
	camPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(9.2); 	// prp


    // add randomness to camera for depth-of-field look close up.
    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;

	// Camera setup.
	vec3 camVec=normalize(camLookat - camPos);//vpn
	vec3 sideNorm=normalize(cross(camUp, camVec));	// u
	vec3 upNorm=cross(camVec, sideNorm);//v
	vec3 worldFacing=(camPos + camVec);//vcv
	vec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord
	vec3 relVec = normalize(worldPix - camPos);//scp

	// --------------------------------------------------------------------------------
	// I put a bounding sphere around the whole object. If the ray is outside
	// of the bounding sphere, I don't bother ray marching. It's just an optimization.
	vec3 iA, iB;
	float hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);

	// --------------------------------------------------------------------------------
	vec2 distAndMat = vec2(0.05, 0.0);
	float t = 0.0;
	float inc = 0.02;
	float maxDepth = 110.0;
	vec3 pos = vec3(0,0,0);
    // start and end the camera ray at the sphere intersections.
    camPos = iA;
    maxDepth = distance(iA, iB);
	// ray marching time
	if (hit > 0.5)	// check if inside bounding sphere before wasting time ray marching.
	{
        for (int i = 0; i < MAX_MARCH_REPS; i++)	// This is the count of the max times the ray actually marches.
        {
            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;
            pos = camPos + relVec * t;
            // *******************************************************
            // This is _the_ function that defines the "distance field".
            // It's really what makes the scene geometry.
            // *******************************************************
            distAndMat = DistanceToObject(pos);
            // adjust by constant because deformations mess up distance function.
            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;
        }
    }
    else
    {
		t = maxDepth + 1.0;
        distAndMat.x = 1.0;
    }
	// --------------------------------------------------------------------------------
	// Now that we have done our ray marching, let's put some color on this geometry.

	vec3 sunDir = normalize(vec3(0.93, 0.0, -1.5));
	vec3 finalColor = vec3(0.0);

	float hitObj = 1.;
	// If a ray actually hit the object, let's light it.
	if (abs(distAndMat.x) < 0.75)
    //if (t <= maxDepth)
	{
        // calculate the normal from the distance field. The distance field is a volume, so if you
        // sample the current point and neighboring points, you can use the difference to get
        // the normal.
        vec3 smallVec = vec3(0.005, 0, 0);
        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,
                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,
                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);

        vec3 normal = normalize(normalU);

        // calculate 2 ambient occlusion values. One for global stuff and one
        // for local stuff - so the green sphere light source can also have ambient.
        float ambientS = 1.0;
        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);
        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);
        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);
        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);
        ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);
        ambient = max(0.15, pow(ambient, 0.3));	// tone down ambient with a pow and min clamp it.
        ambient = saturate(ambient);

        // Trace a ray toward the sun for sun shadows
        float sunShadow = 1.0;
        float iter = 0.2;
		for (int i = 0; i < 10; i++)
        {
            float tempDist = DistanceToObject(pos + sunDir * iter).x;
	        sunShadow *= saturate(tempDist*10.0);
            if (tempDist <= 0.0) break;
            iter *= 1.5;	// constant is more reliable than distance-based
            //iter += max(0.2, tempDist)*1.2;
        }
        sunShadow = saturate(sunShadow);

        // calculate the reflection vector for highlights
        vec3 ref = reflect(relVec, normal);

        // ------ Calculate texture color of the rock ------
        // base texture can be swirled noise.
		vec3 rp = RotateY(pos, pos.y*0.4 - cos(localTime)*0.4);
        float n = noise(rp*4.0) + noise(rp*8.0) + noise(rp*16.0) + noise(rp*32.0);
        n = saturate(n*0.25 * 0.95 + 0.05);
        vec3 texColor = vec3(red,green,blue)*n;

        // fade to reddish texture on outside
        texColor += vec3(0.99, 0.21, 0.213) * clamp(length(pos)-4.0, 0.0, 0.4);
        // give it green-blue texture that matches the shape using normal length
        texColor += vec3(1.0, 21.0, 26.0)*0.6 * saturate(length(normalU)-0.01);
        // Give it a reddish-rust color in the middle
        texColor -= vec3(0.0, 0.3, 0.5)*saturate(-distAndMat.y*(0.9+sin(localTime+0.5)*0.9));
        // make sure it's not too saturated so it looks realistic
        texColor = max(vec3(0.02),texColor);

        // ------ Calculate lighting color ------
        // Start with sun color, standard lighting equation, and shadow
        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*14.0;
        // sky color, hemisphere light equation approximation, anbient occlusion
        lightColor += vec3(0.1,0.35,0.95) * (normal.y * 0.5 + 0.5) * ambient * 0.25;
        // ground color - another hemisphere light
        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.2;

        // finally, apply the light to the texture.
        finalColor = texColor * lightColor;

        // specular highlights - just a little
        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;
        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;

        // fog that fades to sun color so that fog is brightest towards sun
        vec3 fog_color = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));
		finalColor = mix(finalColor, fog_color, fog_strength);
        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);
	} else {
		hitObj = 0.;
	}

    // Our ray trace hit nothing, so draw sky.
    // fade the sky color, multiply sunset dimming
    vec3 sky = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;
    // add the sun
    sky += GetSunColorSmall(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);	
	
	vec3 background_col = mix(max(vec3(0), wet_neurons_col), sky, background_blending*0.7);
	
	finalColor = mix(finalColor, background_col, (1-background_blending*hitObj)) + finalColor;
	

    // vignette?
    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));
    finalColor *= 1.95;
	
	// output the final color with sqrt for "gamma correction"
	fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.);
	
	
	
}



//--------------------------------------------------------------------------
/** SHADERDATA
{
	"title": "fractal pyramid",
	"description": "",
	"model": "car"
}
*/
// <<<<<<<<< END SHADERTOY PASTE

			void main(void) {                
				mainImage(outColor, jit_in.texcoord.st);
			}
        ]]>
        </program>
    </language>
</jittershader>
