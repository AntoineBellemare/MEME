<jittershader name="stripes">
    <param name="modelViewProjectionMatrix" type="mat4" state="MODELVIEW_PROJECTION_MATRIX" />
    <param name="textureMatrix0" type="mat4" state="TEXTURE0_MATRIX" />
    <param name="position" type="vec3" state="POSITION" />
    <param name="texcoord" type="vec2" state="TEXCOORD" />
    <param name="iResolution" type="vec2" state="TEXDIM0" />
    <param name="iMouse" type="vec4" default="0 0 0 0" />
    <param name="iTime" type="float" default="0" />
    <param name="iFrame" type="int" default="0" />
	<param name="dummytex" type="int" default="0" />
	<param name="iChannel0" type="int" default="1" />
	<param name="iChannel1" type="int" default="2" />
	<param name="iChannel2" type="int" default="3" />
    <param name="iChannel3" type="int" default="4" />
	<param name="fog_dyn" type="float" default="0.11" />
	<param name="DETAIL" type="int" default="1" />
	<param name="TEXTURE" type="float" default="2.0" />
	<param name="ROTATE" type="float" default="1.5" />
	<param name="ROTATE_SIN" type="float" default="0.5" />
	<param name="CUTS" type="float" default="3.14" />
	<param name="ZOOM" type="float" default="2.5" />
	<param name="FRAGMENTS" type="float" default="0.1" />
    <language name="glsl" version="1.5">
        <bind param="modelViewProjectionMatrix" program="vp" />
        <bind param="textureMatrix0" program="vp" />
        <bind param="position" program="vp" />
        <bind param="texcoord" program="vp" />
        <bind param="iTime" program="fp" />
        <bind param="iFrame" program="fp" />
        <bind param="iMouse" program="fp" />
        <bind param="iResolution" program="fp" />
		<bind param="dummytex" program="fp" />
		<bind param="iChannel0" program="fp" />
		<bind param="iChannel1" program="fp" />
		<bind param="iChannel2" program="fp" />
        <bind param="iChannel3" program="fp" />
		<bind param="fog_dyn" program="fp" />
		<bind param="DETAIL" program="fp" />
		<bind param="TEXTURE" program="fp" />
		<bind param="ROTATE" program="fp" />
		<bind param="ROTATE_SIN" program="fp" />
		<bind param="CUTS" program="fp" />
		<bind param="ZOOM" program="fp" />
		<bind param="FRAGMENTS" program="fp" />
		<program name="vp" type="vertex"  >
		<![CDATA[
			#version 330 core
			
			in vec3 position;
			in vec2 texcoord;
			out jit_PerVertex {
				vec2 texcoord;
			} jit_out;
			uniform mat4 modelViewProjectionMatrix;
			uniform mat4 textureMatrix0;
			
			void main(void) {
				gl_Position = modelViewProjectionMatrix*vec4(position, 1.);
				jit_out.texcoord = vec2(textureMatrix0*vec4(texcoord, 0., 1.));
			}
		]]>
		</program>      
        <program name="fp" type="fragment"  >
        <![CDATA[
            #version 330 core
            
            in jit_PerVertex {
                vec2 texcoord;
            } jit_in;
            out vec4 outColor;

            uniform float iTime;
            uniform int iFrame;
            uniform vec2 iResolution;
            uniform vec4 iMouse;
			uniform sampler2DRect dummytex;
			uniform sampler2D iChannel0;
			uniform sampler2D iChannel1;
			uniform sampler2D iChannel2;
            uniform sampler2D iChannel3;
			uniform float fog_dyn;
			uniform int DETAIL;
			uniform float TEXTURE;
			uniform float ROTATE;
			uniform float ROTATE_SIN;
			uniform float CUTS;
			uniform float ZOOM;
			uniform float FRAGMENTS;

// <<<<<<<<< START SHADERTOY PASTE

			// Protean clouds by nimitz (twitter: @stormoid)
// https://www.shadertoy.com/view/3l23Rh
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Contact the author for other licensing options

/*
	Technical details:

	The main volume noise is generated from a deformed periodic grid, which can produce
	a large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple
	fetches of volume gradient computation for improved lighting.

	To further accelerate marching, since the volume is smooth, more than half the the density
	information isn't used to rendering or shading but only as an underlying volume	distance to 
	determine dynamic step size, by carefully selecting an equation	(polynomial for speed) to 
	step as a function of overall density (not necessarialy rendered) the visual results can be 
	the	same as a naive implementation with ~40% increase in rendering performance.

	Since the dynamic marching step size is even less uniform due to steps not being rendered at all
	the fog is evaluated as the difference of the fog integral at each rendered step.

*/

// Remnant X
// by David Hoskins.
// Thanks to boxplorer and the folks at 'Fractalforums.com'
// HD Video:- https://www.youtube.com/watch?v=BjkK9fLXXo0

// #define STEREO
/*--------------------------------------------------------------------------------------
License CC0 - http://creativecommons.org/publicdomain/zero/1.0/
To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.
----------------------------------------------------------------------------------------
^This means do anything you want with this code. Because we are programmers, not lawyers.
-Otavio Good
*/

// NEIGHBOR_DIST should be greater than DESIRED_SEPERATION, 
// otherwise you may not observe flocking behaviour.

#define BOID_DENSITY 0.01
#define NEIGHBOR_DIST 6
#define DESIRED_SEPERATION 4
#define MAX_SPEED 0.9
#define MAX_FORCE 0.05

#define PI 3.14159265359
#define NEIGHBOR_DIST_SQR (NEIGHBOR_DIST * NEIGHBOR_DIST)
#define DESIRED_SEPERATION_SQR (DESIRED_SEPERATION * DESIRED_SEPERATION)

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    fragColor = vec4(0, 0, 0, 0);
    
	vec2 uv = (fragCoord.xy) / iResolution.xy;
    
    if(iFrame == 0)
    {
        if(rand(uv) > 1.0 - BOID_DENSITY)
        {
            float angle = rand(vec2(1.0, 1.0) - uv) * PI * 2.0;
            
            vec2 rot = vec2(cos(angle), sin(angle));
            
            fragColor = vec4(fragCoord.xy, rot);
        }
    }
    else
    {
     	vec4 data = texture(iChannel0, uv);
        
        if(data.x > 0.001)
        {
            vec2 pos = data.xy;
            vec2 vel = data.zw;
            
            int nCount = 0;
            int sCount = 0;
            
            vec2 alignment = vec2(0, 0);
            vec2 cohesion = vec2(0, 0);
            vec2 seperation = vec2(0, 0);
            
            for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++)
            {
                for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++)
                {
                    if((i == 0 && j == 0) || (i * i + j * j > NEIGHBOR_DIST_SQR))
                        continue;
                    
                    vec2 coord = fragCoord + vec2(float(i), float(j));

                    coord = mod(coord, iResolution.xy);

                    vec2 uv2 = coord / iResolution.xy;

                    vec4 data2 = texture(iChannel0, uv2);

                    if(data2.x > 0.001)
                    {
                        vec2 pos2 = data2.xy;
            			vec2 vel2 = data2.zw;
                        
                        vec2 toBoid = pos - pos2;
                        
                        float distSqr = dot(toBoid, toBoid); 
                        
                        if(distSqr < float(DESIRED_SEPERATION_SQR))
                        {
                            toBoid /= distSqr;
                            
                            seperation += toBoid;
                            sCount++;
                        }
                        
                        if(distSqr < float(NEIGHBOR_DIST_SQR))
                        {
                            alignment += vel2;
                            cohesion += pos2;
                            nCount++;
                        }
                    }
                }
            }
            
            if(nCount > 0)
            {
            	cohesion /= float(nCount);
                
              	vec2 s = vec2(0, 0);
                vec2 toTarget = cohesion - pos;
                float dist = length(toTarget);
                
                if(dist > 0.0)
                {
                    toTarget *= MAX_SPEED / dist;
                    
                    s = toTarget - vel;
                    
                    float l = length(s);
                    
                    if(l > MAX_FORCE)
                    	s *= MAX_FORCE / l;
                }
                
                cohesion = s;
                
                alignment = normalize(alignment);
                alignment *= float(MAX_SPEED);
                alignment -= vel;
                
                float l = length(alignment);
                
                if(l > MAX_FORCE)
                    alignment *= MAX_FORCE / l;
            }
            
            if(sCount > 0)
            {
                seperation = normalize(seperation);
                seperation *= float(MAX_SPEED);
                seperation -= vel;
                
                float l = length(seperation);
                
                if(l > MAX_FORCE)
                    seperation *= MAX_FORCE / l;
            }
            
            vec2 acc = alignment + seperation * 1.5 + cohesion;
            
            vel += acc;
            
            float l = length(vel);
                
            if(l > float(MAX_SPEED))
                vel *= float(MAX_SPEED) / l;
            
            pos += vel;
            
            pos = mod(pos, iResolution.xy);
            
            fragColor = vec4(pos, vel);
        }
    }
}

//--------------------------------------------------------------------------
/** SHADERDATA
{
	"title": "fractal pyramid",
	"description": "",
	"model": "car"
}
*/
// <<<<<<<<< END SHADERTOY PASTE

			void main(void) {                
				mainImage(outColor, jit_in.texcoord.st);
			}
        ]]>
        </program>
    </language>
</jittershader>
